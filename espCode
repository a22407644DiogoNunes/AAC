#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <Servo.h>

// -------- WIFI --------
const char* WIFI_SSID = "NOS-E386";
const char* WIFI_PASS = "EK397RUY";

// -------- SERVER --------
const char* SERVER_URL = "http://refactored-space-enigma-pj9gj4xq6xvjcq4q-5000.app.github.dev/receive";  // Sem S!

// -------- PINOS --------
#define TRIG_PIN 2      // D4
#define ECHO_PIN 14     // D5
#define SERVO_H_PIN 12  // D6 (horizontal)
#define SERVO_V_PIN 13  // D7 (vertical) ← MUDADO de D3 para evitar problemas de boot

// -------- RADAR --------
#define ROWS 5
#define COLS 41

#define H_MIN 30
#define H_MAX 150
#define H_STEP 3

#define DIST_THRESHOLD_CM 30.0
#define NUM_READINGS 3   // Média de 3 leituras

const int vAngles[ROWS] = {0, 10, 20, 30, 40};  // Ângulos verticais fixos (mais claro)

// -----------------------
Servo servoH;
Servo servoV;

char radar[ROWS][COLS];

// -------- FUNÇÕES --------
void clearRadar() {
  memset(radar, '.', sizeof(radar));
}

float measureDistanceCM() {
  float total = 0;
  int valid = 0;

  for (int i = 0; i < NUM_READINGS; i++) {
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2);
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN, LOW);

    unsigned long duration = pulseIn(ECHO_PIN, HIGH, 30000);  // Timeout 30ms (~5m)
    if (duration > 0) {
      float dist = duration * 0.0343 / 2.0;
      if (dist >= 2 && dist <= 400) {
        total += dist;
        valid++;
      }
    }
    delay(10);  // Pequeno descanso entre leituras
  }

  if (valid == 0) return -1;
  return total / valid;
}

void sendHTTP(const String& payload) {
  if (WiFi.status() != WL_CONNECTED) return;

  WiFiClient client;          // ← Cliente normal (não secure)
  HTTPClient http;

  http.begin(client, SERVER_URL);
  http.addHeader("Content-Type", "application/json");

  String body = "{\"pattern\":\"" + payload + "\"}";
  int code = http.POST(body);

  if (code > 0) {
    Serial.printf("HTTP POST enviado, código: %d\n", code);
  } else {
    Serial.printf("HTTP POST falhou: %s\n", http.errorToString(code).c_str());
  }

  http.end();
}

// -------- SETUP --------
void setup() {
  Serial.begin(115200);

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  servoH.attach(SERVO_H_PIN);
  servoV.attach(SERVO_V_PIN);

  servoH.write(H_MIN);
  servoV.write(vAngles[0]);

  clearRadar();

  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("A conectar ao WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi conectado! IP: " + WiFi.localIP().toString());
}

// -------- LOOP --------
void loop() {
  clearRadar();

  for (int row = 0; row < ROWS; row++) {
    servoV.write(vAngles[row]);
    delay(300);  // Tempo para servo vertical estabilizar

    for (int hAngle = H_MIN; hAngle <= H_MAX; hAngle += H_STEP) {
      servoH.write(hAngle);
      delay(50);  // Tempo suficiente para movimento + medição

      float dist = measureDistanceCM();
      bool detected = (dist > 0 && dist <= DIST_THRESHOLD_CM);

      int col = map(hAngle, H_MIN, H_MAX, 0, COLS - 1);
      col = constrain(col, 0, COLS - 1);

      radar[row][col] = detected ? 'X' : '.';
    }

    // Volta ao início para próxima linha
    servoH.write(H_MIN);
    delay(200);
  }

  // ----- Constrói payload -----
  String payload = "";
  for (int r = 0; r < ROWS; r++) {
    for (int c = 0; c < COLS; c++) {
      payload += radar[r][c];
    }
    if (r < ROWS - 1) payload += "\n";  // ← \n real
  }

  sendHTTP(payload);

  delay(500);  // Pausa entre scans completos
}